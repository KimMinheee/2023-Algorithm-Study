문제 5 나머지 합 

시간제한 1초 / 난이도 골드 3 / 백준 10980 

![](https://velog.velcdn.com/images/kr_diosamor/post/8ab5e258-7d7b-4574-a775-bb3fed2a2925/image.png)



#### 문제 분석하기

N의 최댓값이 106이라 연산량이 적다 생각하기 쉽지만 106개의 수에 대해서 구간합을 모두 구해야 하므로 1초안에 연산이 힘들다는걸 알아야한다. 

핵심 아이디어

1) (A+B) % C = ((A%C)+(B%C))%C 

특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다.

2) 구간 합 배열을 이용한 식 S[i]-S[j]는 원본 배열 j+1부터 1까지의 구간 합이다.

3) S[i] % M의 값과 S[j] % M의 값이 같다면 (S[i]-S[j]) % M은 0이다. 즉 구간 합 뱌열의 원소를 M으로 나눈 나머지로 업데이트 하고 S[i]와 S[j]가 같은 (i,j)쌍을 찾으면 원본 배열에서 j+1부터 i까지의 구간합이 M으로 나누어 떨어진다는 것을 알 수 있다.

#### 손으로 풀어보기

1) A배열의 합 배열 S를 생성

2) 합 배열 S의 모든 값을 M으로 나머지 연산을 수행해 값을 업데이트합니다.

3) 우선 변경된 합 배열에서 원소 값이 0인 개수만 세어 정답에 더합니다. 변경된 합 배열의 원소값이 0이라는 뜻은 원본 배열의 0부터 i까지의 구간합이 이미 M으로 나누어 떨어진다는 뜻이기 때문입니다.

3) 이제 변경된 합 배열에서 원소 값이 같은 인덱스의 개수, 즉 ,나머지 값이 같은 합 배열의 개수를 셉니다. 변경된 합 배열에서 원소 값이 같은 2개의 원소를 뽑는 모든 경우의 수를 구하여 정답에 더하면 됩니다. 



------

#### 슈도코드 작성하기

N 입력받기 (수열의 개수)

M 입력받기(나누어 떨어져야 하는 수)

S 선언하기 (합 배열)

C 선언하기(같은 나머지의 인덱스를 카운트하는 배열)

for(i → 0~N){

remainder = S[i] % M //합 배열을 M으로 나눈 나머지 값

if(remainder ==0)

C[remainder]의 값을 1 증가시키기

} 

for(i → 0 ~ M){

C[i] (i가 나머지인 인덱스의 개수)에서 2가지를 뽑는 경우의 수를 정답에 더하기

// C[i]개 중 2개를 뽑는 경우의 수 계산 공식 C[i] * (C[i]-1)/2

}

결과값 출력

------

#### 코드 구현하기

```java
public class baek_10986 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); //수열의 개수 
        int M = sc.nextInt(); //나누어 떨어져야 하는 수
        long[] S = new long[N]; //합배열 
        long[] C = new long[M]; //같은 나머지의 인덱스를 카운트하는 배열
        long answer = 0;

        S[0] = sc.nextInt();
        for (int i = 1; i < N; i++) { //합 배열 저장
            S[i] = S[i - 1] + sc.nextInt();
        }
        for (int i = 0; i < N; i++) {
            int remainder = (int) (S[i] % M); //합 배열 M으로 나눈 나머지 값
            //0 ~ i까지의 구간 합 자체가 0일때 정답에 더하기
            if (remainder == 0) {//정답을 1증가시킴
                answer++;
            }
            C[remainder]++; //값 증가
        }
        for (int i = 0; i < M; i++) {
            if (C[i] > 1) {
                //나머지가 같은 인덱스중 2개를 뽑는 경우의 수를 더하기
                answer = answer + (C[i] * (C[i] - 1) / 2); //C[i]개 중 2개를 뽑는 경우의 수 계산 공식 C[i]*(C[i]-1) / 2

            }
        }
        System.out.println(answer); //결과 출력
    }
}
```

