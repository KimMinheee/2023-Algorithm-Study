### 탐색범위
```java
 long end = n*n;
 or
 long end = k;
```
정렬되기 전의 1차원배열에서 k보다 작거나 같은 수를 적어도 k개 포함한다. 정렬 후에도 똑같이 k개 포함하므로 굳이 end를 n*n으로 주지 않고 k로 주는 것이 효율적이다.


### k번째 수 찾기
탐색하는 수가 자기보다 작은 값이 k-1개이면 된다. 즉 정렬 후 탐색값보다 작은 수의 개수를 찾아주는 것이 관건
```java
    long cnt = 0;
    for (int i = 1; i <= n; i++) {
        long add = mid/i;
        if(add>n){
            add = n;
        }
        cnt += add;
    }
```
mid : 중앙값, cnt : 작은수 카운트, n : 행렬크기


각 행마다 mid를 각 행렬크기로 나눠줘서 k보다 작거나 같은 수에 해당하는 칸을 카운트해준다.(add), 카운트한 칸의 개수를 행렬이 끝날 때까지 더하기(cnt)

그 후 cnt가 k보다 작을 경우 k번째 값은 더 뒤에 있다는 것이므로 start = mid + 1;로 업데이트해서 다시진행

cnt가 k보다 클 경우 k번째 값은 앞에 있다는 것이므로 end = mid - 1;로 업데이트해서 다시진행

cnt가 k개일 경우 현재 cnt를 가지는 mid가 k번째 수이다.