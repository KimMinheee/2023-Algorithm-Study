## 자료구조 

### 3-1 배열과 리스트 

---

배열 

메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조

인덱스를 통해 참조가능하며 선언한 자료형의 값만 저장이 가능

![](https://t1.daumcdn.net/cfile/tistory/180EB745514C39041E)

배열의 특징 

1) 인덱스를 사용하여 값에 바로 접근

2) 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요하다.

3) 배열의 크기는 선언할대 지정할 수 있으며, 한번 선언하면 크기를 늘리거나 줄일 수 없다.

4) 구조가 간단하므로 코딩 테스트에서 많이 사용한다.



크기가 정해져 있고 데이터에 접근하는 경우가 많을때 사용 

---

리스트

값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조

![](http://www.tcpschool.com/lectures/img_java_singly_linked_list.png)

1) 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야한다. 다시말해 접근하는 속도가 느리다.

2) 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다.

3) 선언할 때 크기를 별도로 지정하지 않아도 된다. 다시 말해 리스트의 크기는 정해져 있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.

4) 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.



크기가 변하는 데이터 데이터의 삽입 삭제가 많은 경우 사용 

---

문제 1 

제한시간 1초 / 난이도 브론즈 2 / 백준 11720 문제

![](https://images.velog.io/images/agugu95/post/9051d9c8-1169-413f-a8d7-8f96c2643d20/image.png)

#### 문제분석 

100자리수가까지 계산해야하므로 int,long 불가 
문자열 형태로 입력값을 받은후에 이를 문자 배열로 반환하고,문자 배열값을 순서대로 읽으면서 숫자형으로 반환해야함 toCharArray 쓰면 자동으로 배열 나누어 담겨짐

※문자열을 int 형으로 바꾸는법 아스키코드 '숫자'- 48 || '숫자'-'0'

#### 손으로 풀어보기 

1) 숫자의 개수만큼 입력받은 값을 String 형으로 저장합니다.

2)String형으로 입력받은 값을 char[]형으로 변환

3)인덱스 0부터 끝까지 배열을 탐색하며 각 값을 정수형으로 변환하고 결괏값에 더하여 누적

#### 슈도 코드

n값을 입력받기 

길이 N의 숫자를 입력받아서 String형 변수 sNum에 저장하기 

sNum을 다시 char []형 변수 cNum에 변환하여 저장하기 

int형 변수 sum선언하기 

for(cNum 길이만큼 반복하기){	

배열의 각 자릿값을 정수형으로 변환하며 sum에 더하여 누적하기 

}

sum 출력하기

```java
//문제풀이 

public class main{
  public static void main(String[] arg){
    Scanner sc =new Scanner(System.in);
    int N = sc.nextInt(); //배열의 자리수 입력 받기
    String sNum=sc.next(); // 숫자 입력받기 String  
    char[] cNum=sNum.toCharArray(); //입력받은 String를 toCharArray로 cNum배열에 각자 나눠서 담음 
    int sum=0; // 합칠 변수
    for(int i=0; i < cNum.length;i++){
      sum+=cNum[i] - '0'; //아스키코드로 변환하면서 길이만큼 더하면서 cNum더해줌 
    }
    System.out.print(sum); // sum 출력 
  }
}

```

---

문제 2 

평균구하기 

시간제한 2초 / 난이도 브론즈1 /백준 1546

![](https://velog.velcdn.com/images/ch4570/post/942b63b9-2c6f-419a-8f46-346b0e329f90/image.png)

#### 문제 분석하기 

최고점을 기준으로 삼기 때문에 최고점에 대한 저장을 따로 하나 해야한다.

 식을 좀 더 간단하게 바꾼다.

(A/M*100+B/M*100+C/M*100)/3 = (A+B+C)*100/M/3

#### 손으로 풀어보기

1) 점수를 1차원 배열로 저장 

2) 배열을 탐색하며 최고점수와 점수의 총합을 구함 

3) 총합 * 100 / 최고점수 / 과목의 수를 계산해 다시 계산한 점수의 평균값을 출력합니다. 

#### 슈도코드 작성하기

변수 n에 과목의 수 입력받기

길이가 n인 1차원 배열 A[]선언하기

for(A[] 길이만큼 반복하기){

A[i]에 각 점수 저장하기 

} 

for(A[] 길이만큼 반복하기){

최고점은 변수 max에, 총점은 변수 sum에 저장하기 

}

sum * 100 / max / N 출력하기

```java
//코드 구현하기 
public static void main(String[] args){
  Scanner sc=new Scanner(System.in);
  int N=sc.nextInt();
  int A[]=NEW int[N];
  for(int i=0;i<N;i++){
    A[i] =sc.nextInt();
  }
  long sum =0;
  long max=0;
  for(int i=0;i<N;i++){
    if(A[i] > max) max = A[i];
    sum=sum+A[i];
  }
  //한 과목과 관련된 수식을 총합한 후 관련된 수식으로 변환해 로직이 간단해짐 
  System.out.println(sum*100.0/max/N);
}
```

---

### 3-2 구간 합

구간합은 합 배열을 이용하여 시간 복잡도를 줄이기 위해 사용하는 특수한 목적의 알고리즘입니다. 

(사용빈도 높음)

구간 합 알고리즘을 활요하시 위해서는 먼저 합배열을 구해야함 

S[i] = A[0] + A[1] + A[2] + ... +A[ i-1 ] + A[ i ]

A[i]부터 A[j]까지의 배열의 합을 합 배열 없이 구하는 경우 최악의 경우 시간복잡도는 O(N)인데, 합배열을 사용하면 O(1)안에 답을 구할 수 있습니다.

합 배열 S 구하는 공식

S[i] = S[i-1] + A[i]

이걸 활용해서 구간 합을 구하는 공식 

S[j] - S[i-1] // i부터 j까지 구간 합

 문제 3 

시간제한 0.5초 / 난이도 실버 3 /백준 11659

![](https://mblogthumb-phinf.pstatic.net/MjAxODEyMDRfMTY4/MDAxNTQzODg2NTU5MjEx.VkIvyG5K_QLqQ2oYr2e-R7s3lxd4o9tQMaKbUZHJf9Ag.FhBC7W4Ud9BsDdgHZIaCFJmRfNxqNwOLFZ68IjSHFHUg.PNG.jhc9639/1.PNG?type=w800)

#### 문제 분석

최대 연산 횟수가 100,000이 두번 있으므로 제한시간인 0.5초 안에 연산이 끝날수가 없다.

→ 시간 단축이 필요하다. → 연산 횟수를 줄인다 → 구간합 적용 하는 문제

#### 손으로 풀어보기

1) N개의 수를 입력받음과 동시에 합 배열을 생성 

2) 구간 i ~ j 가 주어지면 구간 합을 구하는 공식으로 정답을 출력합니다.

#### 슈도 코드 작성하기 

suNo(숫자 개수), quizNo(질의 개수) 저장하기

for(숫자 개수만큼 반복하기){

​	합 배열 생성하기(S[i]=S[i-1]+ A[i])

}

for (질의 개수만큼 반복하기){

​	질의 범위 받기(i-j)

​	구간 합 출력하기 (S[j]-S[i-1])

}

```java
//문제 구현하기

public class P11659_구간합구하기{
  public static void main(String[] args)throws IOException{
    BufferdReader bufferedReader = 
      new BufferedReader(new InputStreamReader(System.in));//받는 개수가 많을때 BufferdReader
    StringTokenizer stringTokenizer =
      new StringTokenizer(bufferedReader.readLine()); 
  //받는 개수가 옆으로 굉장히 길 경우 int 형은 받기 힘들다 string형으로 바꿔서 토큰화해서 사용하는게 좋다.
    //StringTokenizer뒤에 쓴것을 기준으로 분리된다.
    int suNo=Integer.parseInt(stringToken.nextToken());//데이터 개수
    int quizNo =Integer.parseInt(stringTokenizer.nextToken());//질의 개수
    long[] S=new long[suNo + 1]; //합 배열 long형으로 
    stringTokenizer = new StringTokenizer(bufferedReader.readLine());
    for(int i=1;i<=suNo;i++){
      S[i] = S[i-1] + Integer.parseInt(stringTokenizer.nextToken());
    }
    for(int  q=0;q<quizNo;q++){
      stringTokenizer=new StringTokenizer(bufferedReader.readLine());
      int i=Integer.parseInt(stringTokenizer.nextToken());
      int j=Integer.parseInt(stringTokenizer.nextToken());
      System.out.println(S[j]-S[i-1]);
    }
  }
}
```

---

문제 4

구간합 구하기2

시간제한 1초 / 난이도 실버1 / 백준 11660번

 ![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https:%2F%2Fblog.kakaocdn.net%2Fdn%2FUR2mu%2FbtrNExvgO3C%2FOmPleulG7EBAaKq2uUtBpK%2Fimg.png)

#### 문제 분석하기 

질의 개수가 100,000개 이므로 질의마다 합을 구하면 안되고, 구간합 배열을 이용해야 한다는 것을 알 수 있다.

여기서 1차원배열을 2차원으로 바꾼것이 핵심

#### 손으로 풀어보기

1) 2차원구간 합 배열의 1행,1열부터 구합니다. 

2)이를 통해 나머지 2차원 구간 합 배열을 채웁니다.

3)구간합 배열을 이용하기 전에 질의에 대한 답을 도출하기 위한 과정을 원본 배열과 함께 살펴봅시다. 다음은 원본 배열에 구간 합을 표시하여 질의에 대한 답을 도출하는 과정을 보여 줍니다.

만약 질의가 2 2 3 4 라면 3,4 구간합에서 1,4 구간 합 3,1 구간합을 뺀다음 중복된 부분을 더해주면 된다 

따라서 구간합을 사용하면 간단한 공식이 나오는데 D[i][j]=D[i][j-1]+D[i-1][j]-D[i-1][j-1]+A[i][j] 이다.

```java
public class baek_11660 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N =Integer.parseInt(st.nextToken());
        int M =Integer.parseInt(st.nextToken());

        int[][] box=new int[N+1][M+1]; // 0행0열부터 시작하므로 + 1 씩
        for(int i=1;i<=N;i++){
            st=new StringTokenizer(br.readLine());
            for(int j=1;j<=N; j++){
                box[i][j]=Integer.parseInt(st.nextToken());
            }
        }

        int[][] boxSum=new int[N+1][M+1]; // 0행0열부터 시작하므로 + 1 씩
        for(int i=1;i<=N;i++){
            for(int j=1;j<=N; j++){
                //구간 합 공식 D[i][j]=D[i][j-1]+D[i-1][j]-D[i-1][j-1]+A[i][j]
                boxSum[i][j]=boxSum[i][j-1]+boxSum[i-1][j]-boxSum[i-1][j-1]+box[i][j];
            }
        }
        for(int i=0;i < M; i++){ //질의 개수만큼
            st=new StringTokenizer(br.readLine());
            int x1=Integer.parseInt(st.nextToken());
            int y1=Integer.parseInt(st.nextToken());
            int x2=Integer.parseInt(st.nextToken());
            int y2=Integer.parseInt(st.nextToken());

            int result=boxSum[x2][y2]-boxSum[x1-1][y2]-boxSum[x2][y1-1]+boxSum[x1-1][y1-1];
            System.out.println(result);

        }
    }
}

```

---

문제 5 나머지 합 

시간제한 1초 / 난이도 골드 3 / 백준 10986

![](https://velog.velcdn.com/images/kr_diosamor/post/8ab5e258-7d7b-4574-a775-bb3fed2a2925/image.png)



#### 문제 분석하기

N의 최댓값이 106이라 연산량이 적다 생각하기 쉽지만 106개의 수에 대해서 구간합을 모두 구해야 하므로 1초안에 연산이 힘들다는걸 알아야한다. 

핵심 아이디어

1) (A+B) % C = ((A%C)+(B%C))%C 

특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다.

2) 구간 합 배열을 이용한 식 S[i]-S[j]는 원본 배열 j+1부터 1까지의 구간 합이다.

3) S[i] % M의 값과 S[j] % M의 값이 같다면 (S[i]-S[j]) % M은 0이다. 즉 구간 합 뱌열의 원소를 M으로 나눈 나머지로 업데이트 하고 S[i]와 S[j]가 같은 (i,j)쌍을 찾으면 원본 배열에서 j+1부터 i까지의 구간합이 M으로 나누어 떨어진다는 것을 알 수 있다.

#### 손으로 풀어보기 

1) A배열의 합 배열 S를 생성

2) 합 배열 S의 모든 값을 M으로 나머지 연산을 수행해 값을 업데이트합니다.

3) 우선 변경된 합 배열에서 원소 값이 0인 개수만 세어 정답에 더합니다. 변경된 합 배열의 원소값이 0이라는 뜻은 원본 배열의 0부터 i까지의 구간합이 이미 M으로 나누어 떨어진다는 뜻이기 때문입니다.

3) 이제 변경된 합 배열에서 원소 값이 같은 인덱스의 개수, 즉 ,나머지 값이 같은 합 배열의 개수를 셉니다. 변경된 합 배열에서 원소 값이 같은 2개의 원소를 뽑는 모든 경우의 수를 구하여 정답에 더하면 됩니다. 



---

#### 슈도코드 작성하기

N 입력받기 (수열의 개수)

M 입력받기(나누어 떨어져야 하는 수)

S 선언하기 (합 배열)

C 선언하기(같은 나머지의 인덱스를 카운트하는 배열)

for(i → 0~N){

remainder = S[i] % M //합 배열을 M으로 나눈 나머지 값

if(remainder ==0)

C[remainder]의 값을 1 증가시키기

} 

for(i → 0 ~ M){

C[i] (i가 나머지인 인덱스의 개수)에서 2가지를 뽑는 경우의 수를 정답에 더하기

// C[i]개 중 2개를 뽑는 경우의 수 계산 공식 C[i] * (C[i]-1)/2

}

결과값 출력

---

#### 코드 구현하기 

```java
public class baek_10986 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt(); //수열의 개수 
        int M = sc.nextInt(); //나누어 떨어져야 하는 수
        long[] S = new long[N]; //합배열 
        long[] C = new long[M]; //같은 나머지의 인덱스를 카운트하는 배열
        long answer = 0;

        S[0] = sc.nextInt();
        for (int i = 1; i < N; i++) { //합 배열 저장
            S[i] = S[i - 1] + sc.nextInt();
        }
        for (int i = 0; i < N; i++) {
            int remainder = (int) (S[i] % M); //합 배열 M으로 나눈 나머지 값
            //0 ~ i까지의 구간 합 자체가 0일때 정답에 더하기
            if (remainder == 0) {//정답을 1증가시킴
                answer++;
            }
            C[remainder]++; //값 증가
        }
        for (int i = 0; i < M; i++) {
            if (C[i] > 1) {
                //나머지가 같은 인덱스중 2개를 뽑는 경우의 수를 더하기
                answer = answer + (C[i] * (C[i] - 1) / 2); //C[i]개 중 2개를 뽑는 경우의 수 계산 공식 C[i]*(C[i]-1) / 2

            }
        }
        System.out.println(answer); //결과 출력
    }
}
```

